# useImperativeHandler

ketika memforward ref ke child, kita dapat menambahkan fungsi ref tersebut yang dapat dipanggil dari parent. Ini merupakan pattern yang biasa diterapkan pada projek besar, karena bisa saja komponen yang kita gunakan harus dimodifikasi karena komponen child memodifikasi cara menampilkan modal

```jsx
const Input = forwardRef((props, ref) => {
  const inputRef = useRef(); // local_ref

  // memberikan method pada param_ref agar bisa m
  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
  }));

  return <input ref={inputRef} />;
});

const Parent = () => {
  const inputRef = useRef();

  return (
    <>
      <Input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
    </>
  );
};
```

Sebenarnya juga bisa gini

```jsx
const Input = forwardRef((props, ref) => {
  return <input ref={ref} />;
});

const Parent = () => {
  const inputRef = useRef();

  return (
    <>
      <Input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
    </>
  );
};
```

tapi kita tidak mendapatkan manfaat enkapsulasi:

- Parent tidak tahu apa-apa tentang elemen `<input>` internal.
- Parent hanya tahu bahwa inputRef.current punya method focus() dan clear().
