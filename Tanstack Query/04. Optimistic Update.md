# Optimistic Mutation

Dilakukan ketika kita ingin update UI secara instan tanpa menunggu balasan dari BE. Kita hilangkan field `onSuccess` pada `useMutation`. Bersifat optimasi UX saja.

```js
export default function CreatePostWithMutation() {
  const [title, setTitle] = useState("");
  const queryClient = useQueryClient();

  const { postMutate: mutate, isError, error, isSuccess, isPending } = useMutation({
    mutationFn: createPost,
    onMutate: async(data) => {
      await queryClient.cancelQueries(['events', params.id]);  
      // data merupakan argumen dari pemanggilan mutate()
      queryClient.setQueryData(['events', params.id], data.event);

      const prevData = queryClient.getQueryData(['events', params.id])

      return {prevData}
    },
    onError: (error, data, context) => {
      queryClient.setQueryData(['events', params.id], context.prevData)
    }
  });
}
```

## Why do we need to call cancelQueries()

if the in-flight query for ['events', params.id] finishes after your optimistic update, it will overwrite the cache with the **server’s old state** (which doesn’t include the new post yet).

❌ Your optimistic update disappears from the UI.

## What cancelQueries does

It tells TanStack Query: “stop (or mark as canceled) any in-flight queries for this key.”

If a fetch request is still running, TanStack Query marks it as canceled and prevents its result from writing to the cache.

Importantly: cancelQueries resolves its Promise once cancellation is registered, not after the network request finishes.
