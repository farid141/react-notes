# UseQuery Hooks

Digunakan untuk fetching dan caching data.

```js
const {data, isPending, isError, error} = useQuery({
    queryKey: ['some-key'], // array of keyword
    queryFn: fetchData, // pointer ke fungsi fetch data
})
```

Terdapat beberapa param dalam hook:

> pastikan fungsi fetchData melakukan `throw errorMessage` jika error. Agar bisa menggunakan `isError` dan `error`

```js
const function fetchData
const response = await fetch('abc.com');

if(!response.ok){
    const error = new Error('An error occured while fetching the events')
    error.code = response.status
    error.info = await response.json();
    throw error
}

const {events} = await.response.json();
return events
```

## Parameter

- `queryFN`: fungsi `async` yang mengembalikan data dan raise error (lebih mudah pake Axios karena response selain 200 sudah diraise error)
- `staleTime=0`:,(waktu ms, kapan data harus di re-render lagi saat navigasi)
- `gcTim=300000e`(waktu ms, lama data akan disimpan di cache), hapus cache tidak langsung mentrigger fetch.

## Obj return hooks

Pemanggilan hooks tersebut menghasilkan object dnegan beberapa field:

- `data` hasil return fetch
- isError, error (berisi obj error disebabkan fetch function)
- `refetch`, fungsi untuk trigger manual fetch
- `isLoading`, true ketika tidak ada data lama dan sedang fetch
- `isFetching`, true ketika proses fetch berlangsung

### Fetch Time default

Ketika sebuah komponen dirender dan memanggil useQuery, maka akan dilihat key dan cek cache dan secara default instantly  re-fetch belakang layar, tapi bisa kita atur jarak minimum untuk refetch darisebelumnya melalui parameter `staleTime`.

## QueryFn

Merupakan sebuah fungsi yang dijalankan sebagai sumber data. **Secara default menerima beberapa parameter**, maka jika kita tambahkan param ke url harus disesuaikan dengan destructuring.

<https://tanstack.com/query/latest/docs/framework/react/guides/query-functions>

```js
queryFn: ({signal})=>searchEvents({signal, searchTerm})

export func searchEvents({signal, searchTerm}){
    // signal dapat dimanfaatkan untuk abort request (otomatis dipanggil ketika pindah halaman)
    fetch('abc.com', {signal})
}
```

## QueryKey

TanStack Query **mencari cache berdasarkan `queryKey`**. **Array harus 100% match secara urutan dan nilai** supaya dianggap query yang sama.

  ```ts
  ["todos", 1] !== ["todos", 1, "completed"]
  ["todos", 1, "completed"] !== ["todos", "completed", 1]
  ```
  
### Strategi mengurangi cache explosion

Semakin banyak key dapat mengakibatkan masalah efisiensi dan maintainability.

1. Gabungkan parameter kompleks jadi object

   ```ts
   useQuery({
     queryKey: ["todos", { userId: 1, status: "completed", page: 1 }],
     queryFn: fetchTodos,
   });
   ```

   Agar lebih mudah dibaca dan dikelola.
2. Gunakan pagination / infinite queries

   Simpan cache per page, jangan semua item sekaligus.
3. Kontrol `gcTime`

   Hapus cache yang tidak aktif setelah beberapa waktu agar memory tetap terkendali.
4. Gunakan selective invalidation

   Invalidasi hanya query yang relevan, jangan semua cache.
