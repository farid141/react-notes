# Build Prod

Tersedia dua pilihan untuk deployment, yaitu SSR (membutuhkan nodejs berjalan di server).

Perlu diperhatikan proses build nextjs cukup berat, pastikan memori mencukupi

## SSR

Dalam hal ini, proses rendering terjadi di server nodejs.

Buat konfigurasi NGINX untuk reverse proxy arahkan ke port nextjs.

```conf
server {
  listen 80;
  server_name domain.com;
  location / {
    proxy_pass http://localhost:3000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}
```

```bash
npm run build
npm start
```

Jika kamu hosting di subpath (misalnya domain.com/app), perlu atur basePath di next.config.js agar file /_next/static/... tidak error 404.

## Build Statis / Server Side Generation (SSG)

Setiap page dalam aplikasi akan dirender jadi `HTML` saat proses build

```bash
npm run build
npm run export
```

Output-nya ada di folder out/, dan itu bisa kamu upload ke server apa pun seperti file HTML biasa (tanpa Node.js).

```bash
index.html
about/index.html
posts/1/index.html
_next/static/... (JS & CSS)
```

### Masalah Deployment

- getServerSideProps
- app/api/route.js (API Routes Next.js)
- Middleware Next.js (middleware.ts)

itu semua butuh Node.js karena eksekusinya di server runtime.

### Proses dibalik layar

Next.js SSG → banyak file HTML, satu untuk tiap halaman, tapi navigasi di klien tetap terasa seperti SPA.

#### 1. Saat pertama kali buka halaman

Misal kamu buka `https://example.com/posts/1`.

Yang terjadi:

1. Browser minta `posts/1/index.html` (file hasil SSG).
2. File itu sudah berisi HTML lengkap dari halaman itu (judul, isi, dsb).
3. Setelah halaman tampil, Next.js JS runtime (`_next/static/chunks/...`) ikut dimuat.
4. JS ini melakukan **hydration** — “menghidupkan” halaman statis agar interaktif (button bisa diklik, form aktif, dll).

Jadi sampai titik ini, HTML-nya berasal dari hasil build (SSG), bukan dari fetch di runtime.

#### 2. Saat kamu navigasi ke halaman lain (pakai `<Link>` atau `router.push`)

Nah, di sinilah trik ajaibnya:

- Next.js **tidak memuat HTML baru.**
- Ia memanggil JS router internal yang:

  1. Fetch *JS chunk* milik halaman tujuan (mis. `_next/static/chunks/pages/about-xyz.js`).
  2. Jalankan kode React dari chunk itu untuk **merender halaman baru di browser**.
  3. Mengubah URL (dengan `history.pushState`) tanpa reload penuh.

Karena itu terasa seperti pindah halaman “instan”, padahal browser tidak pernah meminta file `about/index.html` dari server.

#### 3. Tapi kalau user buka langsung `/about`

Kalau user ketik `https://example.com/about` di address bar atau refresh di halaman `/about`:

- Browser minta `about/index.html` ke server.
- File itu ada karena hasil SSG, jadi server kasih HTML-nya.
- Browser render, lalu Next.js runtime hidup lagi → hydrasi → siap navigasi lagi tanpa reload.

Dengan begitu, situsmu tetap bisa diakses:

- **Langsung via URL (karena file HTML ada)**
- **Atau lewat navigasi internal cepat (karena router JS aktif)**

#### NGINX

Proses penentuan file html full-reload pertama kali dilakukan diserver konfigurasi NGINX

```conf
location / {
    try_files $uri $uri/ /index.html;
}
```
