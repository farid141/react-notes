# Hybrid Rendering

Dengan memanfaatkan keduanya, akan didapatkan efisiensi rendering serta SEO yang baik.

## Contoh

Di sini akan diberikan contoh pemanfaatan dalam kasus serverside-table.

### Page

```jsx
import Table from "./Table";
import FilterForm from "./FilterForm";

export default async function UsersPage({
  searchParams,
}: {
  searchParams?: { page?: string; role?: string };
}) {
  const page = Number(searchParams?.page ?? 1);
  const role = searchParams?.role ?? "all";

  // simulasi fetch data (di server)
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/users?_page=${page}&_limit=5`,
    { cache: "no-store" } // SSR: ambil data tiap request
  );
  const users = await res.json();

  // di dunia nyata, kamu mungkin filter berdasarkan `role`
  const filtered = role === "all" ? users : users.filter((u: any) => u.role === role);

  return (
    <section>
      <h1 className="text-xl font-bold mb-4">User List</h1>
      <FilterForm selectedRole={role} />
      <Table users={filtered} page={page} />
    </section>
  );
}
```

### Table (ServerSide)

```jsx
export default function Table({
  users,
  page,
}: {
  users: any[];
  page: number;
}) {
  return (
    <div className="mt-4 border rounded">
      <table className="min-w-full border-collapse">
        <thead>
          <tr className="bg-gray-100">
            <th className="border p-2 text-left">ID</th>
            <th className="border p-2 text-left">Name</th>
            <th className="border p-2 text-left">Email</th>
          </tr>
        </thead>
        <tbody>
          {users.map((user) => (
            <tr key={user.id}>
              <td className="border p-2">{user.id}</td>
              <td className="border p-2">{user.name}</td>
              <td className="border p-2">{user.email}</td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Navigasi pagination â€” link ke URL baru */}
      <div className="flex gap-2 p-2">
        <a href={`?page=${page - 1}`} className="text-blue-500 disabled:opacity-50">
          Prev
        </a>
        <a href={`?page=${page + 1}`} className="text-blue-500">
          Next
        </a>
      </div>
    </div>
  );
}

```

### Filter Form (Client Side)

```jsx
"use client";

import { useRouter, useSearchParams } from "next/navigation";

export default function FilterForm({ selectedRole }: { selectedRole: string }) {
  const router = useRouter();
  const params = useSearchParams();

  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newRole = e.target.value;
    const page = params.get("page") ?? "1";
    router.push(`/users?page=${page}&role=${newRole}`);
  };

  return (
    <form className="mb-3">
      <label className="mr-2">Role:</label>
      <select value={selectedRole} onChange={handleChange}>
        <option value="all">All</option>
        <option value="admin">Admin</option>
        <option value="member">Member</option>
      </select>
    </form>
  );
}
```

## Penjelasan

1. Pada komponen utama saat pertama kali render akan dilakukan request di sisi server.
2. Setelah request selesai dilakukan proses rendering server untuk server component (selain filter).
3. Server mengembalikan `html` yang ter-render disertai script js (untuk filter form).
4. Setiap aksi perubahan filter dilakukan request ke server disertai data filter pada query params.
